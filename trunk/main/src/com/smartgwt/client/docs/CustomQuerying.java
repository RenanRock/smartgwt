
package com.smartgwt.client.docs;

/**
 * The SmartGWT server provides a number of ways to let you customize the SQL or Hibernate&#010 query it generates to fetch data from or update your database.  You can provide full &#010 custom queries in either {@link com.smartgwt.client.data.OperationBinding#getCustomSQL customSQL} or &#010 {@link com.smartgwt.client.data.OperationBinding#getCustomHQL customHQL}, or you replace individual parts of the query &#010 ({@link com.smartgwt.client.data.OperationBinding#getWhereClause whereClause}, for example) while letting&#010 SmartGWT generate the rest.  Full custom queries provide complete flexibility, but &#010 they cannot be used for automatic data paging; if you use a full custom query, all of its&#010 data will be returned to the client in one shot.  This may, of course, be perfectly &#010 reasonable, depending on the number of rows involved.  However, if you need automatic &#010 paging support, you should try to implement your customizations by replacing pieces of the&#010 query.&#010 <p>&#010 Query customization is done per {@link com.smartgwt.client.data.OperationBinding}, so it is entirely feasible to &#010 provide multiple custom queries for the same {@link com.smartgwt.client.data.OperationBinding#getOperationType operationType} &#010 on a given {@link com.smartgwt.client.data.DataSource}.&#010&#010 <h4>Using criteria and values</h4>&#010 Whether using full custom queries or individual clauses, your code has access to the &#010 criteria values submitted with the operation; if this is an "add" or "update" operation,&#010 it also has access to the new field values sent from the client.&#010 <p>&#010 Fields are accessed in your SQL or HQL code using the Velocity template language.  You&#010 can refer to container variables <b>$criteria</b> and <b>$values</b> in your queries or &#010 clause snippets, and SmartGWT will insert the appropriate values.  A simple &#010 {@link com.smartgwt.client.data.OperationBinding#getWhereClause whereClause} example:&#010 <p>&#010 <code>&lt;whereClause&gt;continent = $critieria.continent AND population > $criteria.minPop&lt;/whereClause&gt;</code>&#010 <p>&#010 As well as your own fields, both <b>$criteria</b> and <b>$values</b> contain the variables&#010 <code>transactionDate</code> and <code>currentDate</code>.  These are both millisecond-precise&#010 date/time values. <code>transactionDate</code> is set at the start of a queue of&#010 of {@link com.smartgwt.client.data.DSRequest}s and remains the same for each request in the queue; <code>currentDate</code>&#010 is refreshed for each request.  If you are not processing requests in a queue, the two values&#010 are identical.  Example usage, for an "update" operation:&#010 <p>&#010 <code>&lt;valuesClause&gt;price = $values.price, lastUpdated = $values.transactionDate&lt;/valuesClause&gt;</code>&#010 &#010 <h4>Using $fields and $qfields</h4>&#010 To aid in writing custom SQL clauses that are not inextricably tied to one particular &#010 database product, we provide two extra container variables that you can use.&#010 <b>$fields</b> contains the names of all the fields in your DataSource, but quoted in&#010 accordance with the column-quoting rules of the target database.  <b>$qfields</b> also&#010 contains a list of field names, but in this case each one is qualified with its table&#010 name.<p>&#010 As an example of how to use <b>$fields</b> and <b>$qfields</b>, consider a DataSource with&#010 a field called "itemID", bound to a column also called "itemID", and a tableName property &#010 of "orderItem".  Here are three ways to write a {@link com.smartgwt.client.data.OperationBinding#getSelectClause selectClause} for a&#010 custom SQL query that returns that field:<ul>&#010 <li><code>orderItem."itemID"</code>&#010 <li><code>orderItem.$fields.itemID</code>&#010 <li><code>$qfields.itemID</code>&#010 </ul>&#010 The first of these is not portable.  It will work fine in HSQL and Oracle, but will fail &#010 with a syntax error in MySQL, amongst others, because you quote a field name with backticks &#010 in MySQL, not quote marks.  Neither is removing the quotes a solution; now, Oracle will look&#010 for a column called ITEMID, MySQL for a column called itemID and PostgreSQL for a column &#010 called itemid.<p>&#010 The usages via <b>$fields</b> and <b>$qfields</b> <em>are</em> portable.  The second line, &#010 when targeting Oracle, will be translated to <code>orderItem."itemID"</code>; when targeting&#010 MySQL, it will be translated to <code>orderItem.itemID</code>, or <code>orderItem.`itemID`</code>&#010 if column quoting is enabled for that database (it generally isn't required, since MySQL &#010 preserves case by default).<p>&#010 If you want to use these cross-database features, then generally you will want to use &#010 <b>$qfields</b>.  The exception is when you want to join to another table using the same &#010 column name - then, you can use <b>$fields</b> to achieve a portable &#010 {@link com.smartgwt.client.data.OperationBinding#getWhereClause whereClause} like:<p>&#010 <code>$qfields.itemID = supplyItem.$fields.itemID</code>&#010&#010 <h4>Using the default clauses</h4>&#010 You also have access to the default subclauses generated by SmartGWT.  You can use these&#010 in full custom queries to allow a certain part of the query code to be generated:<p>&#010 <code>SELECT foo, bar FROM $defaultTableClause WHERE baz > $criteria.baz</code>.  &#010 <p>&#010 You can also use them, with care, as a foundation for your own additions:<p>&#010 <code>SELECT $defaultSelectClause, foo, bar FROM $defaultTableClause WHERE ($defaultWhereClause) AND baz > $criteria.baz</code>.&#010 <p>&#010 You can also use them within query snippets in the various subclause properties:<p>&#010 <code>&lt;selectClause&gt;$defaultSelectClause, foo, bar&lt;/selectClause&gt;</code>&#010&#010 <h4>Stored procedures</h4>&#010 It is also possible to include templated calls to SQL stored procedures in a&#010 {@link com.smartgwt.client.data.OperationBinding#getCustomSQL customSQL} clause, for the ultimate in flexibility.  For &#010 example, the deletion of an order might require a number of actions: deletion of the order&#010 record itself, messages sent to other systems (data warehousing, maybe, or a central accounts&#010 system running on a mainframe), an event log written, and so on.  You could write a stored &#010 procedure to do all this, and then invoke it with a customSQL clause:<p>&#010 <code>&lt;operationBinding operationType="remove"&gt;<br>&#010 &nbsp;&nbsp;&lt;customSQL&gt;call deleteOrder($criteria.orderNo)&lt;customSQL&gt;<br>&#010 &lt;/operationBinding&gt;</code><p>&#010&#010 <h4>Custom queries are safe</h4>&#010 Custom queries are protected from SQL injection attacks, because anything coming from the&#010 client is escaped before use.  So, in a typical SQL injection attack an attacker might &#010 enter his User Number as "123 OR 1 = 1", in the hope that this will generate a query&#010 with a where clause that looks like this: <code>WHERE userNumber = 123 OR 1 = 1</code>.  With &#010 SmartGWT custom queries, this cannot happen.  If the userNumber column is a string, &#010 the where clause would look like this: <code>WHERE userNumber = '123 OR 1 = 1'</code>. If &#010 the userNumber column is numeric, SmartGWT would log a complaint that "123 OR 1 = 1" is&#010 not a numeric value, and would generate a standard false clause: <code>WHERE '0' = '1'</code>.&#010 <p>&#010 Further, custom queries can be protected from buggy or ad hoc client requests because the &#010 query is specified on the server.  For example you could add a custom where clause, as shown&#010 in the above section on default clauses, to ensure that certain records are never seen by&#010 the client.  For example: <p>&#010 <code>&lt;whereClause&gt;($defaultWhereClause) AND confidential = '0'&lt;/whereClause&gt;</code>.
 * @see com.smartgwt.client..DefaultQueryClause
 * @see com.smartgwt.client.data.OperationBinding#getSelectClause
 * @see com.smartgwt.client.data.OperationBinding#getTableClause
 * @see com.smartgwt.client.data.OperationBinding#getWhereClause
 * @see com.smartgwt.client.data.OperationBinding#getGroupClause
 * @see com.smartgwt.client.data.OperationBinding#getOrderClause
 * @see com.smartgwt.client.data.OperationBinding#getValuesClause
 * @see com.smartgwt.client.data.OperationBinding#getCustomSQL
 * @see com.smartgwt.client.data.OperationBinding#getCustomHQL
 * @see com.smartgwt.client.data.OperationBinding#getCustomValueFields
 * @see com.smartgwt.client.data.OperationBinding#getCustomCriteriaFields
 * @see com.smartgwt.client.data.OperationBinding#getUseForCacheSync
 * @see com.smartgwt.client.data.OperationBinding#getCacheSyncOperation
 * @see com.smartgwt.client.data.OperationBinding#getCanSyncCache
 */
public interface CustomQuerying {
}
