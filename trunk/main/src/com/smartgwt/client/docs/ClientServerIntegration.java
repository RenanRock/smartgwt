
package com.smartgwt.client.docs;

/**
 * Like client-server desktop applications, SmartGWT browser-based applications interact with remote data and services via background communication channels. Background requests retrieve chunks of data rather than new HTML pages, and update your visual components in place rather than rebuilding the entire user interface. <P> SmartGWT supports two general classes of client-server operations: {@link com.smartgwt.client.data.DSRequest} (DataSource Requests) and {@link com.smartgwt.client.rpc.RPCRequest}s (Remote Procedure Call Requests).  DataSource requests are for manipulating structured data described by {@link com.smartgwt.client.data.DataSource}.  RPCRequests are a low-level, very flexible mechanism for custom client-server communications.  In an nutshell, RPCRequests: <ul> <li> may contain arbitrary data <li> are always initiated by custom code (a call to {@link com.smartgwt.client.rpc.RPCManager#send}), and have their responses handled by custom code (the callback passed to <code>send()</code>) </ul> <P> DSRequests: <ul> <li> contain data that follows the {@link com.smartgwt.client.docs.DataSourceOperations 'DataSource protocol'}, which reflect the 4 basic operations on stored records: fetch, update, create, remove. <li> are initiated by ${isc.DocUtils.linkForRef('interface:DataBoundComponent','DataBoundComponents')} in response to user actions, and have their responses automatically managed (for example,  {@link com.smartgwt.client.data.ResultSet} and  {@link com.smartgwt.client.widgets.form.DynamicForm#saveData}).  DSRequests can also be initiated manually and have their responses handled with custom code. </ul> See the {@link com.smartgwt.client.rpc.RPCManager} documentation for further information on RPCRequests - the remainder of this document focuses on integrating DataSource operations with your server. <P> <b>DataSource Creation</b> <p> First you must create {@link com.smartgwt.client.data.DataSource} that describe the objects from your object model that will be loaded or manipulated within your application.  All of ISC's most powerful functionality builds on the concept of a DataSource, and because of ISC's  databinding framework (see ${isc.DocUtils.linkForRef('interface:DataBoundComponent')}), it's as easy to create a DataSource that can configure an unlimited number of components as it is to configure a single component. <P> There are a number of options for creating DataSources; for early prototyping, creating a DataSource by hand in either JavaScript or XML is simplest (this is covered under  {@link com.smartgwt.client.docs.DataSourceDeclaration 'DataSource declaration'}).  Later on, you can pursue one of many {@link com.smartgwt.client.docs.MetadataImport 'metadata import'} strategies for automatically leveraging your existing metadata. <p> Once you have a DataSource, you can bind a ${isc.DocUtils.linkForRef('interface:DataBoundComponent')} such as a  {@link com.smartgwt.client.widgets.grid.ListGrid} to it, call one of the  {@link com.smartgwt.client.docs.DataBoundComponentMethods 'DataBound Component Methods'} on it, such as {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData}, the ListGrid will send a background HTTP request to the server asking for data.  You can set the log category "RPCManager" to DEBUG threshold to see the outbound request and the server's response. <P> In this case, the ListGrid is sending a DataSource operation request of type "fetch".  To fulfill it, you will need to provide a set of matching records in one of many possible formats. <P> At this point your code is just a handful of lines (this example shows a DataSource created in JavaScript): <pre>     DataSource.create({         ID:"employees",         fields:[              ...          ]     });     ListGrid.create({         ID:"myGrid",         dataSource:"employees"     });     myGrid.fetchData(); </pre> If you now bind a {@link com.smartgwt.client.widgets.form.DynamicForm} to your DataSource, you can use the  {@link com.smartgwt.client.widgets.form.DynamicForm#editSelectedData} and {@link com.smartgwt.client.widgets.form.DynamicForm#saveData} methods to cause the client to submit "update" operations.  For both "update" and "add" operations, the DSRequest object you receive will have inbound data that is expected to be committed to your data model.   <P> <b>Data Integration</b> <P> There are two main approaches to integrating DataSources with your server technology: <ul> <li> {@link com.smartgwt.client.docs.ServerDataIntegration 'Server-side integration'}: DataSource requests from the browser arrive as Java Objects on the server.  You deliver responses to the browser by returning Java Objects. <li> {@link com.smartgwt.client.docs.ClientDataIntegration 'Client-side integration'}: DataSource requests arrive as simple HTTP requests which your server code receives directly (in Java, you use the Servlet API or .jsps to handle the requests).  Responses are sent as XML or JSON which you directly generate.   </ul> Note that using WSDL-described web services is also considered a client-side integration approach, although in this case it is typical to use extensive third-party web service libraries such as <a href='http://ws.apache.org/axis/' onclick="window.open('http://ws.apache.org/axis/');return false;">Apache Axis</a> to provide Java bindings. <P> The possible approaches are summarized in the diagram below.  Paths 2, 3, and 4 are client-side integration approaches, and path 1 includes all server-side integration approaches. <P> <img src="${isc.DocViewer.instance.referenceRoot}skin/ds_bindings.png" width=763 height=475> <P> All of these integration options can be used in parallel within the same application.  For example, an application that typically talks to a Java backend may contact Yahoo's JSON-based search services to get related search results, or integrate with SalesForce applications via the AppForce WSDL-described web service. <P> If you cannot install the SmartGWT Server or must integrate with a pre-existing web service, then you must pursue {@link com.smartgwt.client.docs.ClientDataIntegration 'client-side integration'}. Otherwise there are several factors to consider: <ul> <li> With an existing Java backend, the fastest integration approach is {@link com.smartgwt.client.docs.ServerDataIntegration 'server-side integration'} using  {@link com.smartgwt.client..DMI}.  Given  a Java method that returns a Collection of POJOs, a short XML declaration will achieve data loading.</li> <li> If you are building an  <a href='http://www.google.com/search?q=SOA+architecture' onclick="window.open('http://www.google.com/search?q=SOA+architecture');return false;">SOA Architecture</a>, and some of the services that your SmartGWT application needs to contact could be shared with other kinds of clients, consider the WSDL- or XML-based {@link com.smartgwt.client.docs.ClientDataIntegration 'Client-Side Integration'}.</li> <li> The SmartGWT server accelerates Java integration and provides various useful facilities, including the broadest possible browser support, server-push, and network performance enhancements.  See the {@link com.smartgwt.client.docs.IscServer 'SmartGWT Server Summary'} for details.</li> </ul>
 */
public interface ClientServerIntegration {
}
