
package com.smartgwt.client.docs;

/**
 * Like client-server desktop applications, SmartGWT browser-based applications interact&#010 with remote data and services via background communication channels. Background requests&#010 retrieve chunks of data rather than new HTML pages, and update your visual components in&#010 place rather than rebuilding the entire user interface.&#010 <P>&#010 <b>DataSources</b>&#010 <p>&#010 First you must create {@link com.smartgwt.client.data.DataSource} that describe the objects from&#010 your object model that will be loaded or manipulated within your application.  All of &#010 SmartGWT's most powerful functionality builds on the concept of a DataSource, and because &#010 of SmartGWT's databinding framework (see {@link com.smartgwt.client.widgets.DataBoundComponent}), it's as easy to &#010 create a DataSource that can configure an unlimited number of components as it is to &#010 configure a single component.&#010 <P>&#010 For background information on how to create DataSources, {@link com.smartgwt.client.widgets.DataBoundComponent}&#010 components to DataSources and initiate {@link com.smartgwt.client.data.DSRequest}s, please see the <em>Data &#010 Binding</em> chapter of the <em>SmartGWT Quickstart Guide</em>.&#010 <P>&#010 <b>Data Integration</b>&#010 <P>&#010 DataSources provide a data-provider agnostic API to SmartGWT Visual Components that &#010 allow them to perform the 4 CRUD operations (<b>C</b>reate, <b>R</b>etrieve, &#010 <b>U</b>pdate, <b>D</b>elete).  By "agnostic" we mean that the implementation details - &#010 the nuts and bolts of how a given DataSource actually retrieves or updates data - are &#010 unknown to bound SmartGWT components.  One effect of this is that DataSources are &#010 "pluggable": they can be replaced without affecting the User Interface.&#010 <p>&#010 When a visual component, or your own custom code, performs a CRUD operation on a DataSource,&#010 the DataSource creates a {@link com.smartgwt.client.data.DSRequest} (DataSource Request) representing the operation.&#010 "Data Integration" is the process of fulfilling that DSRequest by creating a corresponding&#010 {@link com.smartgwt.client.data.DSResponse} (DataSource Response), by using a variety of possible approaches to &#010 connect to the ultimate data provider.&#010 <p>&#010 SmartGWT supports, out of the box, codeless connectivity to various kinds of common data&#010 providers, including SQL and Hibernate.  SmartGWT also provides functionality and tools&#010 for accelerated integration with broad categories of data providers, such as Java&#010 Object-based persistence mechanisms (JPA, EJB, Ibatis, in-house written systems), and REST &#010 and WSDL web services in XML or JSON formats.  Ultimately, a DataSource can be connected to &#010 anything that is accessible via HTTP or HTTPS, and also to in-browser persistence engines &#010 such as <a href=http://gears.google.com>Google Gears</a>.&#010 <p>&#010 <b>Choosing a Data Integration Approach</b><p>&#010 This section aims to help you decide which of the many possible data integration approaches&#010 is best for your particular circumstances.  The recommendations given here will guide you&#010 to the approach that involves the least effort.<p>&#010 <img src="skin/dataIntegrationFlowchart.png">&#010 <p>&#010 <ul>&#010 <li>If you have a Java server</li>&#010 <ul><li>If your ultimate storage is a SQL database</li>&#010   <ul>&#010       <li>If you are already committed to Hibernate, use the Hibernate DataSource</li>&#010       <li>Otherwise, use the SQL DataSource</li>&#010       <li>Be sure to read the overview of {@link com.smartgwt.client.docs.SqlVsJPA 'SQL DataSource vs JPA'} and&#010           other technologies.  If you ultimately decide not to use the SQL or &#010           Hibernate DataSource, write a {@link com.smartgwt.client.docs.WriteCustomDataSource 'generic DataSource'}</li>&#010       <li>Derive DataSource definitions from existing tables using &#010           ${isc.DocUtils.linkForExampleId('sqlWizard', 'Visual Builder wizards')} or the Batch DataSource &#010           Generator tool.  Or, generate tables from DataSource definitions you create by &#010           hand</li>&#010   </ul>&#010     <li>If your ultimate storage is not SQL, write a &#010         {@link com.smartgwt.client.docs.WriteCustomDataSource 'generic DataSource'}</li>&#010     <li>Whether or not your storage is SQL, add business logic either declaratively in the &#010         DataSource definition, via {@link com.smartgwt.client..DMI}, or any combination of the two&#010   <ul><li>The &lt;criteria&gt; and &lt;values&gt; properties of an {@link com.smartgwt.client.data.OperationBinding}&#010           allow you to dynamically set data values at transaction-processing time, using &#010           built-in {@link com.smartgwt.client.docs.VelocitySupport 'Velocity support'}</li>&#010       <li>Override the <code>validate()</code> method of the DataSource to provide extra&#010           custom validations - just call <code>super</code> to obtain the list of errors &#010           derived from SmartGWT validations, then add to that list as required with your&#010           own custom code</li>&#010       <li>Override the <code>execute()</code> method of the DataSource to add extra processing&#010           either before or after the SmartGWT processing</li>&#010       <li>Use {@link com.smartgwt.client..DSRequestModifier#getValue value} to dynamically set&#010           data values according to the results of earlier transactions</li>&#010       <li>For SQL DataSources, use {@link com.smartgwt.client.docs.CustomQuerying 'SQL Templating'} to change, &#010           add to or even completely replace the SQL sent to the database, and to implement&#010           special query requirements</li>&#010       <li>For Hibernate DataSources, use {@link com.smartgwt.client.data.OperationBinding#getCustomHQL customHQL}&#010           to implement special query requirements</li>&#010   </ul>&#010 </ul>&#010 </ul>&#010 <ul>&#010 <li>If you do not have a Java server</li>&#010 <ul><li>Firstly, consider approaches for {@link com.smartgwt.client.docs.UsingServerWithNonJava 'using the SmartGWT Server framework with non-Java technologies'}.&#010         Using one of these approaches will allow you to leverage SmartGWT Server features &#010         that you might otherwise have to write and maintain yourself</li>&#010     <li>If you cannot use the SmartGWT Server, or decide you do not wish to</li>&#010   <ul><li>If you are not obliged to use a pre-existing network protocol, use the &#010           {@link com.smartgwt.client.data.RestDataSource}</li>&#010       <li>If you are obliged to use WSDL (Web Service Definition Language) and you have WSDL&#010           experience, use the {@link com.smartgwt.client.data.WSDataSource}.  We do not recommend this approach&#010           except in these circumstances; generally, RestDataSource is a better approach</li>&#010       <li>Otherwise, use a {@link com.smartgwt.client.docs.ClientDataIntegration 'client-side data integration'} approach</li>&#010   </ul>&#010 </ul>&#010 </ul>&#010 <p><br>&#010 <b>RPCs: Unstructured Server Communication</b>&#010 <P>&#010 SmartGWT also supports "unstructured" client-server operations.  These &#010 {@link com.smartgwt.client.rpc.RPCRequest}s (Remote Procedure Call Requests) are a low-level, very flexible &#010 mechanism for custom client-server communications.  In an nutshell, RPCRequests:&#010 <ul>&#010 <li> may contain arbitrary data&#010 <li> are always initiated by custom code (a call to {@link com.smartgwt.client.rpc.RPCManager#send}), and have&#010 their responses handled by custom code (the callback passed to <code>send()</code>)&#010 </ul>&#010 <P>&#010 RPCRequests are relatively rare.  Most client-server communications are better done in a &#010 structured fashion using a {@link com.smartgwt.client.data.DSRequest} (DataSource Request).  Note that <em>any</em>&#010 RPCRequest can alternatively be framed as a {@link com.smartgwt.client..dataSource#fetch}; &#010 depending on the circumstances, this may be more convenient.&#010 <P>&#010 See the {@link com.smartgwt.client.rpc.RPCManager} documentation for further information on RPCRequests.
 */
public interface ClientServerIntegration {
}
