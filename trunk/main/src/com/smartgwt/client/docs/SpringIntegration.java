
package com.smartgwt.client.docs;

/**
 * <b>Overview</b> <P> The Spring framework has many different parts, from integration with Object Relational Mapping (ORM) and transaction management systems, to a Model View Controller (MVC) architecture. <P> If you are building a new application from scratch and/or you are trying to  modernize the presentation layer of an existing application, most of Spring MVC is inapplicable in the {@link com.smartgwt.client.docs.SmartArchitecture 'SmartGWT architecture'}.  Specifically, SmartGWT renders <b>all</b> HTML on the client, and the server is responsible only for retrieving data and enforcing business rules.  This means that Spring's ModelAndView and all functionality related to retrieving and rendering Views is unnecessary in SmartGWT. SmartGWT only needs the Model, and provides methods to deliver that Model to SmartGWT components (the server side method DSResponse.setData()). <P> However, Spring's DispatchServlet, Handler chain, and Controller architecture is applicable to SmartGWT.  See "Using Spring Controllers" below. <P> <b>Existing Spring Application</b> <P> As discussed under the general {@link com.smartgwt.client.docs.ClientServerIntegration 'server integration'} topic, integrating SmartGWT into your application involves finding a way to provide data that fulfills the {@link com.smartgwt.client.data.DSRequest} sent by SmartGWT components. <P> There are 2 approaches for integrating SmartGWT into an existing Spring application: <ul> <li> <b>configure Spring to return XML or JSON responses</b>: create variants on existing Spring workflows that use a different type of View in order to output XML or JSON data instead of complete HTML pages.  The SmartGWT {@link com.smartgwt.client.data.RestDataSource} provides a standard "REST" XML or JSON-based protocol you can implement, or you can adapt generic {@link com.smartgwt.client.data.DataSource} to existing formats. <P> In some Spring applications, all existing Spring workflows can be made callable by SmartGWT with a generic View class capable of serializing the Model to XML or JSON, combined with a Controller that always uses this View.  Consider the following Java anonymous class, which uses the SmartGWT JSTranslater class to dump the entire  Spring Model as a JSON response. <pre>  new View() {        public void render(Map model, HttpServletRequest request,                           HttpServletResponse response) throws IOException {                final ServletOutputStream outputStream = response.getOutputStream();                response.setContentType("application/x-javascript");                outputStream.println(JSTranslater.get().toJS(model));                outputStream.close();        }        public String getContentType() {                return "application/x-javascript";        }  } </pre> <P> If you use this approach, you do not need to install the SmartGWT server, and can {@link com.smartgwt.client.docs.IscInstall 'deploy'} SmartGWT as simple web content (JS/media/HTML files).  If you are already familiar with how to generate XML from objects that typically appear in your Spring Models, this may be the easiest path. <P> <li> <b>call Spring beans via SmartGWT DMI</b>: use SmartGWT Direct Method Invocation (DMI) to map {@link com.smartgwt.client.data.DSRequest} to beans managed by Spring, via {@link com.smartgwt.client..ServerObject#getLookupStyle lookupStyle}:"spring".   Return data to the browser by either simply returning it from your method, or via calling DSResponse.setData() (server-side method).   If, from a bean created by Spring, you can easily create the data you typically use to populate a Model in a ModelAndView, this may be the easiest path. </ul> <P> <b>Using Spring Controllers with SmartGWT DMI</b> <P> You can create a Controller that invokes standard SmartGWT server request processing, including DMI, like so: <pre> public class SmartGWTRPCController extends AbstractController {     public ModelAndView handleRequest(HttpServletRequest request,                                        HttpServletResponse response)         throws Exception     {         // invoke SmartGWT server standard request processing         com.isomorphic.rpc.RPCManager.processRequest(request, response);         return null; // avoid default rendering     } } </pre> This lets you use Spring's DispatchServlet, Handler chain and Controller architecture as a pre- and post-processing model wrapped around SmartGWT DMI.
 */
public interface SpringIntegration {
}
